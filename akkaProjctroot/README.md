### Akka notes

- `Test`:
  1. `sbt` on console.
  2. `test` inside sbt repl or `"Test / testOnly *YourTestClassName"` if you'd prefer to run single test.
- The Actor’s `mailbox` is essentially `a message queue with ordering semantics`.
  - The order of multiple messages sent from the `same Actor` is `preserved`, but `can be interleaved` with messages sent by `another Actor`.
- Actor Architecture:
  - For example, if we create an actor named `someActor` from the `user guardian` with `context.spawn(someBehavior, "someActor")`, its reference will include the path `/user/someActor`.
- `Stop an actor`:
  - The recommended pattern is to return `Behaviors.stopped()` inside the actor to stop itself, `usually as a response to some user defined stop message` or `when the actor is done with its job`.
  - `Stopping a child actor`:
    - Technically possible by calling `context.stop(childRef)` `from the parent`, but it’s not possible to stop `arbitrary (non-child) actors` this way.
- `Failure handling:
  - The default `supervisor strategy` is `to stop the child`. If you don’t define the strategy `all failures result in a stop`.
- In the world of actors, protocols take the place of interfaces. While it is not possible to formalize general protocols in the programming language, we can compose their most basic element, `messages`. So, we will `start by identifying the messages` we will want to send to device actors.
  - Typically, `messages fall into categories, or patterns`.
    - One of them is `the request-respond message pattern`
- `It can be difficult to determine the definition of the Succuss of Delivery`:
  - `The guarantee of delivery` does not translate to `the domain level guarantee`. We only want to report success once the order has been actually fully processed and persisted. The only entity that can report success is the application itself, since only it has any understanding of the domain guarantees required. `No generalized framework can figure out the specifics of a particular domain and what is considered a success in that domain`.
- `Device manager hierarchy`: we will model the `device manager component` as an actor tree with three levels:
  - `The top level supervisor actor` represents the system component for devices. It is also the entry point to `look up and create device group and device actors`.
  - At the next level, `group actors` each `supervise the device actors` for one group id (e.g. one home). They also provide services, such as `querying temperature readings` from all of the available devices in their group.
  - `Device actors` manage all `the interactions with the actual device sensors`, such as storing temperature readings.
- `Death Watch feature`: allows an actor to watch another actor and be notified if the other actor is stopped. Unlike `supervision`, watching is not limited to parent-child relationships, any actor can watch any other actor as long as it knows the `ActorRef`
  - After a watched actor stops, the watcher receives a `Terminated(actorRef) signal` which also contains the `reference to the watched actor`. The watcher can either handle this message explicitly or will fail with a `DeathPactException`. This latter is useful if the actor can no longer perform its own duties after the watched actor has been stopped. In our case, the group should still function after one device have been stopped, so we need to handle the `Terminated(actorRef) signal`.
- `Dealing with possible scenarios with Iot devices`:
  - `Scenarios`:
    - When a query arrives, the group actor takes a `snapshot` of the existing device actors and will only ask those actors for the temperature.
    - Actors that start up `after` the query arrives are ignored.
    - If an actor in the `snapshot` stops during the query without answering, we will report the fact that it stopped to teh sender of the query message.
  - Device actor states with respect to a temperature query:
    - It has a temperature available: `Temperature`.
    - It has responded, but has no temperature available yet: `TemperatureNotAvailable`.
    - It has stopped before answering: `DeviceNotAvailable`.
    - It did not respond before the deadline: `DeviceTimedOut`.
- `ActorContext is not thread safe`, thus
  - must not accessed by threads from `scala.concurrent.Future` callbacks
  - must not be shared between several actor instances
- When the `guardian` actor stops this will stop the `ActorSystem`.
- `The terminated message is generated independent of the order in which registration and termination occur`:
  - In particular, the `watching actor(observer)` will receive a `terminated message` even if the `watched actor(observable)` has already been terminated at the time of registration.
  - `Registering multiple times` does not necessarily lead to multiple messages being generated, but there is `no guarantee` that only exactly one such message is received: if termination of the `watched actor` has generated and queued the message, and another registration is done before this message has been processed, then a second message will be queued, because registering for monitoring of an already terminated actor leads to the immediate generation of the terminated message.
    - In other words, if you generate a second actor after a first actor has been terminated, then you will get multiple messages.
  - `Deregister` from watching another actor’s liveliness by using `context.unwatch(target)`:
    - This works even if `the terminated message` has already been enqueued in the mailbox; after calling `unwatch` no terminated message for that actor will be processed anymore.
- `Interaction Patterns`:
  - `Send Future result to self`: means literally `sending the Future result to self`. When the result is `Future`, `onComplete` is a common way to deal with asynchronous process, but in Actor system, doing so is not thread safe. Thus, use this pattern with `pipeToSelf` method.
    - `pipeToSelf` wraps `Future[result]` to `result`, and send it to self mailbox, so that you doesn't have to handle `Future`.
  - `Per session child Actor`:
    - used when creating `Response` after collecting multiple answers from other actors.
    - it's better to use `ask` if all you need is a single response with a timeout.
    - As the protocol of the session `actor` is not a public API but rather `an implementation detail of the parent actor`, it may not always make sense to have an explicit protocol and adapt the messages of the actors that the session actor interacts with. For this use case it is possible to express that the actor can receive any message (`Any`).
- `Fault Tolerance`:
  - When the behavior is restarted the original `Behavior` that was given to `Behaviors.supervise` is re-installed, which means that if it contains `mutable state` it must be a factory via `Behaviors.setup`. When using the object-oriented style with a class extending `AbstractBehavior` it’s always recommended to create it via `Behaviors.setup` as described in [`Behavior factory method`](https://doc.akka.io/docs/akka/current/typed/style-guide.html#behavior-factory-method). For the `function style` there is typically `no need` for the factory if the state is captured in immutable parameters.
  - `Wrapping behaviors`: with the functional style it is very common to store state by changing behavior. Each returned behavior will be re-wrapped automatically with the supervisor.
  - `Not recreate child actor when parent stops`:
    - `supervise` should be placed inside the `setup` and using `SupervisorStrategy.restart.withStopChildren(false)`
      - That means that the `setup block` will only be run when `the parent actor is first started`, and not when it is restarted.
  - `PostStop` is not emitted for a restart, so typically you need to handle both `PreRestart` and `PostStop` to cleanup resources.
  - If the parent in turn does not handle the `Terminated(or ChildFailed)` message it will itself fail with an `akka.actor.typed.DeathPactException`.
- `Routers`:
  - `Pool Router`: is created with `a routee Behavior` and spawns a number of children with that behavior which it will then forward messages to.
  - If `a child` is stopped the pool router removes it from its set of `routees`. When `the last child` stops `the router itself stops`. To make a resilient router that deals with failures `the routee` Behavior must be `supervised`.
  - As `actor children` are always local the `routees` are `never spread across a cluster with a pool router`.
  - `Routing strategies`:
    - `Round Robin`: rotates over the set of routees making sure that if there are n routees, then for n messages sent through the router, each actor is forwarded one message:
      - This is `the default for pool routers` as the pool of routees is expected to remain the same.
      - An optional parameter `preferLocalRoutees` can be used for this strategy. Routers will only use routees located in local actor system if `preferLocalRoutees` is `true` and local routees `do exist`. The default value for this parameter is `false`.
    - `Random`: Randomly selects a routee when a message is sent through the router.
      - This is the default for group routers as the group of routees is expected to change as nodes join and leave the cluster.
      - As `Round Robin` has, `Random` has `preferLocalRoutees` option as well.
    - `Consistent Hashing`: Uses [consistent hashing](https://en.wikipedia.org/wiki/Consistent_hashing) to select a routee based on the sent message(with the same hash are routed to the same routes). This [article](http://tom-e-white.com/2007/11/consistent-hashing.html) gives good insight into how consistent hashing is implemented.
  - `Routers and performance`:
    - Note that if the routees are sharing a resource, `the resource will determine if increasing the number of actors will actually give higher throughput or faster answers`. For example if `the routees are CPU bound actors` it will not give better performance to create more routees than there are threads to execute the actors.
- `Stash`:
  - A typical example when this is useful:
    - If the actor has to load some initial state or initialize some resources before it can accept the first real message
    - When the actor is waiting for something to complete before processing the next message
  - Example:
    - The `DataAccess` actor is used like `a single access point` to a value stored in a database. When it’s started it loads current state from the database, and while waiting for that initial value `all incoming messages are stashed`.
- [`Finite state machine(FSM or finite-state automaton (FSA, plural: automata), finite automaton, or simply a state machine)`](https://en.wikipedia.org/wiki/Finite-state_machine): An `abstract machine` that can be in exactly one of a finite number of states at any given time.
- Related behaviors to `Behaviors.unhandled`:
  - `Behaviors.empty`: as next behavior in case you reached a state where you don’t expect messages any more. For instance if an actor only waits until all spawned child actors stopped. Unhandled messages `are still logged` with this behavior.
  - `Behaviors.ignore`: as next behavior in case you don’t care about unhandled messages. All messages sent to an actor with such a behavior are simply dropped and ignored (`without logging`)
- `Coordinated Shutdown`:
  - `Most relevant default phases`:
    - `before-service-unbind`: The first pre-defined phase during shutdown.
    - `before-cluster-shutdown`: Phase for custom application tasks that are to be run after `service shutdown and before cluster shutdown`.
    - `before-actor-system-terminate`: Phase for custom application tasks that are to be run `after cluster shutdown and before ActorSystem termination`.
  - Tasks added to the same phase are executed in `parallel` without any ordering assumptions. Next phase `will not` start until all tasks of previous phase have been completed.
  - `If tasks are not completed within a configured timeout (see reference.conf) the next phase will be started anyway`. It is possible to configure `recover=off` for a phase `to abort the rest of the shutdown process if a task fails or is not completed within the timeout`.
  - Tasks should typically be registered as early as possible after system startup. When running the coordinated shutdown tasks that have been registered will be performed but tasks that are added too late will not be run.
  - The `coordinated shutdown process` is also started once `the actor system’s root actor is stopped`.
- `Dispatcher`:
  - By default a `Dispatcher` with the configured `akka.actor.default-dispatcher.executor` is used. If no executor is selected a `fork-join-executor` is selected, which gives excellent performance in most cases.
  - To protect the internal Actors that are spawned by the various Akka modules, `a separate internal dispatcher is used by default`. The internal dispatcher can be tuned in a fine-grained way with the setting `akka.actor.internal-dispatcher`, it can also be replaced by another dispatcher by making `akka.actor.internal-dispatcher`
